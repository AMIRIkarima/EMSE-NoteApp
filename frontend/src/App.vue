
<!-- 
  This the root component of our Vue app, it displays the list of notes, each note is rendered by an instance
  of the vue Note component. Latter, we will also add components for the note creation form, the filter list,
  and the message pop up.

  All the code in this file (called a Vue Single File Component), will be translated by the Vue toolchain into
  pure javascript and CSS, sent to the browser. Under the hood, it works thanks to a bundler tool, here it's Vite,
  but it could also be Webpack.

  See: https://vuejs.org/guide/scaling-up/sfc.html
-->

<!-- 
  Here we define the template of our component, that reflects the HTML that will be generated by the Vue engine
-->
<template>
  <error-overlay />
  <Filter @status-changed="onStatusChanged" />
  <div class="notes-container">
   

   
    <Note 
      v-for="note in filteredNotes" 
      :key="note.id" 
      :note="note"
      @delete-note="deleteNote"
      @tasks-updated="onTasksUpdated"
    ></Note>

    <NoteCreationForm @note-created="addNewNote"></NoteCreationForm>
  </div>
</template>


<!-- 
  Here we write our javascript logic, that will be executed within the Vue framework (so we must follow its convention)

  I choose to use the "Options" API of VueJS, over the "Composition" API because IMO it leads to clearer code.

  See: https://vuejs.org/guide/extras/composition-api-faq
-->
<script>
  import {HOST} from './config.js'
  import Note from './Note.vue'
  import NoteCreationForm from './NoteCreationForm.vue'
  import ErrorOverlay from './ErrorOverlay.vue'
  import Filter from './Filter.vue'

  export default {
    components: {
      Note,
      NoteCreationForm,
      ErrorOverlay,
      Filter
    },
    data() {
      return {
        notesList: [],
        selectedStatus: ''
      }
    },
    methods: {
      /* 
       * Here we put methods, that is functions that could be called from the template. If the output
       * of such methods were dependent of the state of variables declared in `data`, it would be better
       * to put them under `computed`
       */
      addNewNote(newNote) {
        this.notesList.push(newNote)
      },
      deleteNote(noteId) {
        console.log('[App] deleteNote called for id=', noteId)
        fetch(`${HOST}/notes/${noteId}`, { method: 'DELETE' })
          .then(async res => {
            console.log('[App] delete response status=', res.status)
            if (!res.ok) {
              const body = await res.text().catch(() => '')
              console.error('[App] delete failed', res.status, body)
              throw new Error('Failed to delete note')
            }

            this.notesList = this.notesList.filter(n => n.id !== noteId)
            console.log('[App] note removed from notesList', noteId)
          })
          .catch(err => {
            console.error('[App] deleteNote error', err)
            alert('Failed to delete note: ' + (err && err.message ? err.message : 'unknown'))
          })
      },
      onTasksUpdated(noteId, nbTasks) {
        const idx = this.notesList.findIndex(n => n.id === noteId)
        if (idx !== -1) this.notesList[idx].nbTasks = nbTasks
      },
      onStatusChanged(newStatus) {
        this.selectedStatus = newStatus
      }
    },
    computed: {
      filteredNotes() {
        if (this.selectedStatus === 'all') return this.notesList
        return this.notesList.filter(note => note.status === this.selectedStatus)
      }
    },
    mounted() {
      fetch(`${HOST}/notes`)
        .then(res => res.json())
        .then(res => this.notesList = res);
    }
  }
</script>


<!--
  Here we write our stylesheet rules that will apply to the HTML generated for this Vue component. The Vue engine
  will "scope" this rules, so they can apply only to your component and not other parts of the web page, even if your use 
  class names that exist elsewhere (you can inspect in your browser developper tools how it's done)

  Also, the Vue framework handles for us the transpilation of other stylesheet languages into pure CSS. Here we use SCSS

  See: https://vuejs.org/api/sfc-css-features.html
-->
<style lang="scss" scoped>
@use 'assets/stylesheets/mediaQueryScreens.scss';

$gutter-size: 15px;

.notes-container {
  display: flex;
  flex-wrap: wrap;
  gap: $gutter-size;

  margin-right: auto;
  margin-left: auto;

  border: 1px solid gray;
  border-radius: 10px;

  padding: $gutter-size;
}

@include mediaQueryScreens.small { 
  .notes-container {
    width: 90vw;
  }

}

@include mediaQueryScreens.medium { 
  .notes-container {
    width: 80vw;
  }

}

@include mediaQueryScreens.large { 
  .notes-container {
    width: 1024px;
  }
}
</style>
